package me.neznamy.tab.bridge.shared.util;

import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import org.jetbrains.annotations.NotNull;

import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Utility class storing methods working with reflection
 */
@NoArgsConstructor(access = AccessLevel.PRIVATE)
public class ReflectionUtils {

    /**
     * Returns {@code true} if class with given full name exists,
     * {@code false} if not.
     *
     * @param path Full class path and name
     * @return {@code true} if exists, {@code false} if not
     */
    public static boolean classExists(@NonNull String path) {
        try {
            Class.forName(path);
            return true;
        } catch (ClassNotFoundException | NullPointerException e) {
            return false;
        }
    }

    /**
     * Returns all fields of class with defined class type
     *
     * @param clazz class to check fields of
     * @param type  field type to check for
     * @return list of all fields with specified class type
     */
    public static List<Field> getFields(@NonNull Class<?> clazz, @NonNull Class<?> type) {
        List<Field> list = new ArrayList<>();
        for (Field field : clazz.getDeclaredFields()) {
            if (field.getType() == type) {
                list.add(setAccessible(field));
            }
        }
        return list;
    }

    /**
     * Returns method with specified possible names and parameters. Throws exception if no such method was found
     *
     * @param clazz          lass to get method from
     * @param names          possible method names
     * @param parameterTypes parameter types of the method
     * @return method with specified name and parameters
     * @throws NoSuchMethodException if no such method exists
     */
    public static Method getMethod(@NonNull Class<?> clazz, @NonNull String[] names, @NonNull Class<?>... parameterTypes) throws NoSuchMethodException {
        for (String name : names) {
            try {
                return clazz.getMethod(name, parameterTypes);
            } catch (NoSuchMethodException e) {
                //not the first method in array
            }
        }
        List<String> list = new ArrayList<>();
        for (Method m : clazz.getMethods()) {
            if (m.getParameterCount() != parameterTypes.length) continue;
            Class<?>[] types = m.getParameterTypes();
            boolean valid = true;
            for (int i = 0; i < types.length; i++) {
                if (types[i] != parameterTypes[i]) {
                    valid = false;
                    break;
                }
            }
            if (valid) list.add(m.getName());
        }
        throw new NoSuchMethodException("No method found with possible names " + Arrays.toString(names) + " with parameters " +
                Arrays.toString(parameterTypes) + " in class " + clazz.getName() + ". Methods with matching parameters: " + list);
    }

    /**
     * Returns all methods from class which return specified class type and have specified parameter types.
     *
     * @param clazz          Class to get methods from
     * @param returnType     Return type of methods
     * @param parameterTypes Parameter types of methods
     * @return List of found methods matching requirements. If nothing is found, empty list is returned.
     */
    public static List<Method> getMethods(@NonNull Class<?> clazz, @NonNull Class<?> returnType, @NonNull Class<?>... parameterTypes) {
        List<Method> list = new ArrayList<>();
        for (Method m : clazz.getMethods()) {
            if (m.getReturnType() != returnType || m.getParameterCount() != parameterTypes.length)
                continue;
            Class<?>[] types = m.getParameterTypes();
            boolean valid = true;
            for (int i = 0; i < types.length; i++) {
                if (types[i] != parameterTypes[i]) {
                    valid = false;
                    break;
                }
            }
            if (valid) list.add(m);
        }
        return list;
    }

    /**
     * Returns list of instance fields matching class type
     *
     * @param clazz     Class to get instance fields of
     * @param fieldType Type of field
     * @return List of instance fields with defined class type
     */
    public static List<Field> getInstanceFields(@NonNull Class<?> clazz, @NonNull Class<?> fieldType) {
        List<Field> list = new ArrayList<>();
        for (Field field : clazz.getDeclaredFields()) {
            if (field.getType() == fieldType && !Modifier.isStatic(field.getModifiers())) {
                list.add(setAccessible(field));
            }
        }
        return list;
    }

    /**
     * Makes object accessible.
     *
     * @param o Object to make accessible
     * @return Provided object
     */
    public static @NotNull <T extends AccessibleObject> T setAccessible(@NonNull T o) {
        o.setAccessible(true);
        return o;
    }
}